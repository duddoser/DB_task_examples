# -*- coding: utf-8 -*-
"""Лабораторная_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Tio-Qm6_FPYeceS_geJJUObGxxPEOi3u
"""

# Не забудьте подключить chinook.db заранее

import sqlite3
sqlite3.sqlite_version  # 3.40.0

# Commented out IPython magic to ensure Python compatibility.
import os
from IPython.display import clear_output
!curl https://www.sqlite.org/src/tarball/sqlite.tar.gz?r=release | tar xz
# %cd sqlite/
!./configure
clear_output()
!make sqlite3.c
# %cd /content
!npx degit coleifer/pysqlite3 -f
!cp sqlite/sqlite3.[ch] .
!python setup.py build_static build
!ls build
!ls build/lib.linux-x86_64-3.8/pysqlite3/
!ls /usr/lib/ | grep python
clear_output()
!cp build/lib.linux-x86_64-3.8/pysqlite3/_sqlite3.cpython-38-x86_64-linux-gnu.so \
     /usr/lib/python3.8/lib-dynload/
os._exit(00)

# Commented out IPython magic to ensure Python compatibility.
# %load_ext sql
# %sql sqlite:///chinook.db
# %sql select SQLITE_VERSION()

"""Проверяем, что версия корректна

## Задание 1
Для каждого артиста вывести все жанры, которые есть в его песнях, и для каждого жанра вывести наиболее продолжительную песню этого артиста.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT Name, gname genre, tname track, duration
# FROM
# (
# SELECT  art.Name as Name, g.Name as gname, t.Name as tname, t.Milliseconds/1000 as duration,
#         row_number()
#             over (partition by art.Name, g.Name order by t.Milliseconds desc) tr
#   FROM artists art
#     JOIN albums alb ON art.ArtistId = alb.ArtistId
#     JOIN tracks t ON alb.AlbumId = t.AlbumId
#     JOIN genres g ON t.GenreId = g.GenreId
# )
# WHERE tr = 1;
#

"""## Задание 2
Для каждого плейлиста вывести трек с наибольшей продолжительностью, трек с наименьшей стоимостью (если у треков одинаковая стоимость, то вывести тот, который весит меньше всех), и жанр данного плейлиста (жанром плейлиста называется тот жанр, треков которого больше всех в плейлисте).
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# WITH max_dur AS (
#   SELECT id, tname1, MAX(rnk_dur) as dur
#   FROM
#   (
#   SELECT  plt.PlaylistId as id, t.Name as tname1,
#           rank() OVER (
#             PARTITION BY plt.PlaylistId
#             ORDER BY t.Milliseconds DESC) rnk_dur
#     FROM tracks t
#     JOIN playlist_track plt ON t.TrackId = plt.TrackId
#   )
#   GROUP BY id
# ),
# 
# min_p AS (
#   SELECT id, tname2, MIN(rnk_p) as price
#   FROM
#   (
#     SELECT plt.PlaylistId as id, t.Name as tname2,
#       rank() OVER (
#         PARTITION BY plt.PlaylistId
#         ORDER BY t.Unitprice, t.Bytes) rnk_p
#     FROM tracks t
#     JOIN playlist_track plt ON t.TrackId = plt.TrackId
#   )
#   GROUP BY id
# ),
# 
# pl_genre AS (
#   SELECT id, gname, MAX(n_g)
#   FROM
#   (
#   SELECT  plt.PlaylistId as id, g.Name as gname,
#           row_number() OVER (
#             PARTITION BY plt.PlaylistId, g.Name
#             ORDER BY g.Name DESC) n_g
#     FROM tracks t
#     JOIN genres g ON t.genreid = g.genreid
#     JOIN playlist_track plt ON t.TrackId = plt.TrackId
#   )
#   GROUP BY id
# )
# 
# SELECT Name, tname1 as longest_track, tname2 as lowest_price_tr, gname as playlist_genre
# FROM playlists pls
# JOIN max_dur md ON pls.PlaylistId = md.id
# JOIN min_p mp ON pls.PlaylistId = mp.id
# JOIN pl_genre pg ON pls.PlaylistId = pg.id

"""## Задание 3

Для каждого жанра вывести треки, которые встречались в большем числе заказов,
сумму, потраченную на данные треки, количество купленных треков и компанию, которая больше всех приобрела данную композицию.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# 
# WITH t AS (
#   SELECT genres.Name as gen, tracks.Name as tr,
#         count(invoices.InvoiceId) as cot,
#         sum(invoice_items.Quantity * invoice_items.UnitPrice) as s, Company,
#         tracks.TrackId as trid, genres.GenreId as genid
#         FROM tracks
#           JOIN playlist_track ON playlist_track.TrackId = tracks.TrackId
#           JOIN playlists ON playlist_track.PlaylistId = playlists.PlaylistId
#           JOIN genres ON genres.GenreId = tracks.GenreId
#           JOIN invoice_items ON invoice_items.TrackId = tracks.TrackId
#           JOIN invoices ON invoices.InvoiceId = invoice_items.InvoiceId
#           JOIN customers ON customers.CustomerId = invoices.CustomerId
#             WHERE customers.Company is not NULL
#               GROUP BY tracks.TrackId
#                 ORDER BY count(invoices.InvoiceId) desc, gen
# )
# SELECT *
# FROM (SELECT gen genre, tr track, company,
#       sum(s) OVER (PARTITION BY genid ORDER BY cot DESC) as sum,
#     sum(cot) OVER (PARTITION BY genid ORDER BY cot DESC) as amount,
#     row_number() OVER (PARTITION BY genid ORDER BY cot) as row_number
#     from(t))
# WHERE row_number = 1

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# WITH max_number AS (
#     SELECT g_id, MAX(rn) as maxn
#   FROM
#   (
#   SELECT  g.GenreId as g_id,
#           rank()
#               over (partition by tr.TrackId, g.GenreId order by int.InvoiceId ) rn
#     FROM tracks tr
#       JOIN invoice_items int ON tr.TrackId = int.TrackId
#       JOIN genres g ON tr.GenreId = g.GenreId
#   )
#   GROUP BY g_id
# ),
# 
# new_table AS (
#     SELECT gname, tname, rn as number, i_id, price, q
#   FROM
#   (
#   SELECT  g.Name as gname, tr.Name as tname, int.InvoiceId as i_id, tr.UnitPrice as price, int.Quantity as q, mn.maxn,
#           rank()
#               over (partition by tr.TrackId, g.GenreId order by int.InvoiceId ) rn
#     FROM tracks tr
#       JOIN invoice_items int ON tr.TrackId = int.TrackId
#       JOIN genres g ON tr.GenreId = g.GenreId
#       JOIN max_number mn ON g.GenreId = mn.g_id
#   )
#   WHERE rn =  maxn
# ),
# 
# max_company AS (
#   SELECT tname1, MAX(w), company1
#   FROM (
#     SELECT tr.Name as tname1, Company as company1, COUNT(int.InvoiceId) as w
#       FROM tracks tr
#       JOIN invoice_items int ON tr.TrackId = int.TrackId
#       JOIN invoices ins ON int.InvoiceId = ins.InvoiceId
#       JOIN customers c ON ins.CustomerId = c.CustomerId
#       GROUP BY tname1, company1
#   )
#   GROUP BY tname1
# )
# 
# 
# SELECT gname as genre, tname as track, number*q*price spent_money, number*q as number, mc.company1
# FROM Invoices ins
# JOIN new_table nt ON ins.InvoiceId = nt.i_id
# JOIN max_company mc ON nt.tname = mc.tname1
# ;